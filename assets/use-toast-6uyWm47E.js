var D=e=>{throw TypeError(e)};var M=(e,t,s)=>t.has(e)||D("Cannot "+s);var r=(e,t,s)=>(M(e,t,"read from private field"),s?s.call(e):t.get(e)),p=(e,t,s)=>t.has(e)?D("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,s),f=(e,t,s,i)=>(M(e,t,"write to private field"),i?i.call(e,s):t.set(e,s),s),S=(e,t,s)=>(M(e,t,"access private method"),s);import{aX as P,aY as Q,aZ as x,a_ as V,a$ as L,Q as k,r as m,b0 as q,b1 as N,R as w}from"./index-CPt7zHrL.js";var h,c,o,a,u,y,I,U,X=(U=class extends P{constructor(t,s){super();p(this,u);p(this,h);p(this,c);p(this,o);p(this,a);f(this,h,t),this.setOptions(s),this.bindMethods(),S(this,u,y).call(this)}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){var i;const s=this.options;this.options=r(this,h).defaultMutationOptions(t),Q(this.options,s)||r(this,h).getMutationCache().notify({type:"observerOptionsUpdated",mutation:r(this,o),observer:this}),s!=null&&s.mutationKey&&this.options.mutationKey&&x(s.mutationKey)!==x(this.options.mutationKey)?this.reset():((i=r(this,o))==null?void 0:i.state.status)==="pending"&&r(this,o).setOptions(this.options)}onUnsubscribe(){var t;this.hasListeners()||(t=r(this,o))==null||t.removeObserver(this)}onMutationUpdate(t){S(this,u,y).call(this),S(this,u,I).call(this,t)}getCurrentResult(){return r(this,c)}reset(){var t;(t=r(this,o))==null||t.removeObserver(this),f(this,o,void 0),S(this,u,y).call(this),S(this,u,I).call(this)}mutate(t,s){var i;return f(this,a,s),(i=r(this,o))==null||i.removeObserver(this),f(this,o,r(this,h).getMutationCache().build(r(this,h),this.options)),r(this,o).addObserver(this),r(this,o).execute(t)}},h=new WeakMap,c=new WeakMap,o=new WeakMap,a=new WeakMap,u=new WeakSet,y=function(){var s;const t=((s=r(this,o))==null?void 0:s.state)??V();f(this,c,{...t,isPending:t.status==="pending",isSuccess:t.status==="success",isError:t.status==="error",isIdle:t.status==="idle",mutate:this.mutate,reset:this.reset})},I=function(t){L.batch(()=>{var s,i,n,b,d,O,R,C;if(r(this,a)&&this.hasListeners()){const l=r(this,c).variables,E=r(this,c).context;(t==null?void 0:t.type)==="success"?((i=(s=r(this,a)).onSuccess)==null||i.call(s,t.data,l,E),(b=(n=r(this,a)).onSettled)==null||b.call(n,t.data,null,l,E)):(t==null?void 0:t.type)==="error"&&((O=(d=r(this,a)).onError)==null||O.call(d,t.error,l,E),(C=(R=r(this,a)).onSettled)==null||C.call(R,void 0,t.error,l,E))}this.listeners.forEach(l=>{l(r(this,c))})})},U);function B(e,t){const s=k(),[i]=m.useState(()=>new X(s,e));m.useEffect(()=>{i.setOptions(e)},[i,e]);const n=m.useSyncExternalStore(m.useCallback(d=>i.subscribe(L.batchCalls(d)),[i]),()=>i.getCurrentResult(),()=>i.getCurrentResult()),b=m.useCallback((d,O)=>{i.mutate(d,O).catch(q)},[i]);if(n.error&&N(i.options.throwOnError,[n.error]))throw n.error;return{...n,mutate:b,mutateAsync:n.mutate}}const Y=1,j=1e6;let _=0;function F(){return _=(_+1)%Number.MAX_SAFE_INTEGER,_.toString()}const g=new Map,K=e=>{if(g.has(e))return;const t=setTimeout(()=>{g.delete(e),T({type:"REMOVE_TOAST",toastId:e})},j);g.set(e,t)},G=(e,t)=>{switch(t.type){case"ADD_TOAST":return{...e,toasts:[t.toast,...e.toasts].slice(0,Y)};case"UPDATE_TOAST":return{...e,toasts:e.toasts.map(s=>s.id===t.toast.id?{...s,...t.toast}:s)};case"DISMISS_TOAST":{const{toastId:s}=t;return s?K(s):e.toasts.forEach(i=>{K(i.id)}),{...e,toasts:e.toasts.map(i=>i.id===s||s===void 0?{...i,open:!1}:i)}}case"REMOVE_TOAST":return t.toastId===void 0?{...e,toasts:[]}:{...e,toasts:e.toasts.filter(s=>s.id!==t.toastId)}}},v=[];let A={toasts:[]};function T(e){A=G(A,e),v.forEach(t=>{t(A)})}function Z({...e}){const t=F(),s=n=>T({type:"UPDATE_TOAST",toast:{...n,id:t}}),i=()=>T({type:"DISMISS_TOAST",toastId:t});return T({type:"ADD_TOAST",toast:{...e,id:t,open:!0,onOpenChange:n=>{n||i()}}}),{id:t,dismiss:i,update:s}}function H(){const[e,t]=w.useState(A);return w.useEffect(()=>(v.push(t),()=>{const s=v.indexOf(t);s>-1&&v.splice(s,1)}),[e]),{...e,toast:Z,dismiss:s=>T({type:"DISMISS_TOAST",toastId:s})}}export{H as a,Z as t,B as u};
